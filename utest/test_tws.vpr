domain Math {

    function Math_Clip(a: Int): Int
    function Math_Min(a: Int, b: Int): Int


    axiom math_clip_nonneg {
        forall a: Int :: { Math_Clip(a) } 0 <= a ==> Math_Clip(a) == a
    }

    axiom math_clip_neg {
        forall a: Int :: { Math_Clip(a) } a < 0 ==> Math_Clip(a) == 0
    }

    axiom math_min {
        true 
        && ( forall a: Int, b: Int :: { Math_Min(a,b) } a <= b <==> Math_Min(a,b) == a )
        && ( forall a: Int, b: Int :: { Math_Min(a,b) } b <= a <==> Math_Min(a,b) == b )
        && ( forall a: Int, b: Int :: { Math_Min(a,b) } Math_Min(a,b) == a || Math_Min(a,b) == b )
    }
}

domain MultiSet {

    function ___IsGoodMultiSet___(ms: MultiSet): Bool
    function _(ms: MultiSet, e: Int): Int // mapping function; returns the number of "e"s in ms.
    function MultiSet_Includes(ms: MultiSet, e: Int): Bool
    function MultiSet_Update(ms: MultiSet, x: Int, n: Int): MultiSet // updates (the number of "x"s in ms) with n. 
    function MultiSet_Card(ms: MultiSet): Int // cardinality
    function MultiSet_Empty(): MultiSet
    function MultiSet_Singleton(e: Int): MultiSet
    function MultiSet_UnionOne(ms: MultiSet, e: Int): MultiSet
    function MultiSet_Union(msx: MultiSet, msy: MultiSet): MultiSet
    function MultiSet_Intersection(msx: MultiSet, msy: MultiSet): MultiSet
    function MultiSet_Difference(msx: MultiSet, msy: MultiSet): MultiSet
    //function MultiSet_Subset(msx: MultiSet, msy: MultiSet): Bool
    function MultiSet_Equal(msx: MultiSet, msy: MultiSet): Bool
    //function MultiSet_Disjoint(msx: MultiSet, msy: MultiSet): Bool
    //function MultiSet_FromSet(set: Set[Int]): MultiSet
    function MultiSet_FromSeq(seq: Seq[Int]): MultiSet
    
    axiom ms_includes {
        forall ms: MultiSet, e: Int :: 
            { MultiSet_Includes(ms,e) }
                MultiSet_Includes(ms,e) <==> 0 < _(ms,e)
    }

    axiom ms_update {
        forall ms: MultiSet, x: Int, n: Int :: 
            { MultiSet_Update(ms, x, n) }
                _(MultiSet_Update(ms, x, n), x) == n
    }

    axiom ms_good_multiSet { 
        forall ms: MultiSet :: 
            { ___IsGoodMultiSet___(ms) } 
                ___IsGoodMultiSet___(ms) <==> 
                forall bx: Int :: { _(ms,bx) } 0 <= _(ms,bx) && _(ms,bx) <= MultiSet_Card(ms)
    }

    axiom ms_card_nonneg {
        forall ms: MultiSet :: { MultiSet_Card(ms) } 0 <= MultiSet_Card(ms)
    }

    /*
        axiom (forall<T> s: MultiSet T, x: T, n: int :: 
          { MultiSet#Card(s[x := n]) } 
          0 <= n ==> MultiSet#Card(s[x := n]) == MultiSet#Card(s) - s[x] + n);
    */
    axiom ms_card_update {
        forall ms: MultiSet, x: Int, n: Int ::
            { MultiSet_Card( MultiSet_Update(ms,x,n) ) }
                0 <= n ==> MultiSet_Card( MultiSet_Update(ms,x,n) ) == MultiSet_Card(ms) - _(ms,x) + n
    }

    axiom ms_empty {
        forall o: Int :: { _(MultiSet_Empty(),o) } _(MultiSet_Empty(),o) == 0 
    }

    axiom ms_empty_card {
        forall ms: MultiSet ::
            { MultiSet_Card(ms) }
                ( MultiSet_Card(ms) == 0 <==> ms == MultiSet_Empty() ) && 
                ( MultiSet_Card(ms) != 0 <==> exists x: Int :: 0 < _(ms,x) )
    }

    axiom ms_singleton {
        forall r: Int, o: Int ::
            { _(MultiSet_Singleton(r),o) }
                ( _(MultiSet_Singleton(r),o) == 1 <==> r == o ) &&
                ( _(MultiSet_Singleton(r),o) == 0 <==> r != o )
    }

    axiom ms_singleton_from_empty {
        forall r: Int :: 
            { MultiSet_Singleton(r) }
                MultiSet_Singleton(r) == MultiSet_UnionOne(MultiSet_Empty(), r)
    }

    axiom ms_unionone {
        forall ms: MultiSet, x: Int, o: Int :: 
            { _(MultiSet_UnionOne(ms, x),o) }
                0 < _(MultiSet_UnionOne(ms, x),o) <==> o == x || 0 < _(ms,o) 
    }

    axiom ms_unionone_plus_one {
        forall ms: MultiSet, x: Int ::
            { MultiSet_UnionOne(ms, x) }
                _(MultiSet_UnionOne(ms, x),x) == _(ms,x) + 1 
    }

    axiom ms_unionone_lookup_nonneg {
        forall ms: MultiSet, x: Int, y: Int :: 
            { MultiSet_UnionOne(ms, x), _(ms,y) }
                0 < _(ms,y) ==> 0 < _(MultiSet_UnionOne(ms, x),y)
    }

    axiom ms_unionone_lookup {
        forall ms: MultiSet, x: Int, y: Int ::
            { MultiSet_UnionOne(ms, x), _(ms,y) }
                x != y ==> _(ms,y) == _(MultiSet_UnionOne(ms, x),y)
    }

    axiom ms_unionone_card {
        forall ms: MultiSet, x: Int ::
            { MultiSet_Card(MultiSet_UnionOne(ms, x)) }
                MultiSet_Card(MultiSet_UnionOne(ms, x)) == MultiSet_Card(ms) + 1
    }

    axiom ms_union {
        forall msx: MultiSet, msy: MultiSet, o: Int ::
            { _(MultiSet_Union(msx,msy),o) } 
                _(MultiSet_Union(msx,msy),o) == _(msx,o) + _(msy,o)
    }

    axiom ms_union_card {
        forall msx: MultiSet, msy: MultiSet :: 
            { MultiSet_Card(MultiSet_Union(msx,msy)) }
                MultiSet_Card(MultiSet_Union(msx,msy)) == MultiSet_Card(msx) + MultiSet_Card(msy)
    }

    axiom ms_intersection {
        forall msx: MultiSet, msy: MultiSet, o: Int :: 
            { _(MultiSet_Intersection(msx,msy),o) }
                _(MultiSet_Intersection(msx,msy),o) == Math_Min(_(msx,o), _(msy,o))
    }

    axiom ms_intersection_double_1 {
        forall msx: MultiSet, msy: MultiSet ::
            { MultiSet_Intersection(MultiSet_Intersection(msx,msy), msy) }
                MultiSet_Intersection(MultiSet_Intersection(msx,msy), msy) == 
                MultiSet_Intersection(msx,msy)
    }

    axiom ms_intersection_double_2 {
        forall msx: MultiSet, msy: MultiSet ::
            { MultiSet_Intersection(msx, MultiSet_Intersection(msx,msy)) }
                MultiSet_Intersection(msx, MultiSet_Intersection(msx,msy)) == 
                MultiSet_Intersection(msx,msy)
    }

    axiom ms_difference {
        forall msx: MultiSet, msy: MultiSet, o: Int ::
            { _(MultiSet_Difference(msx,msy),o) }
                _(MultiSet_Difference(msx,msy),o) == Math_Clip(_(msx,o) - _(msy,o))
    }

    axiom ms_difference_zero {
        forall msx: MultiSet, msy: MultiSet, o: Int ::
            { MultiSet_Difference(msx,msy), _(msy,o), _(msx,o) }
                _(msx,o) <= _(msy,o) ==> _(MultiSet_Difference(msx,msy),o) == 0
    }
    axiom ms_difference_card {
        forall msx: MultiSet, msy: MultiSet :: 
            { MultiSet_Card(MultiSet_Difference(msx,msy)) }
                (
                    MultiSet_Card(MultiSet_Difference(msx,msy)) + 
                    MultiSet_Card(MultiSet_Difference(msy,msx)) +
                    2 * MultiSet_Card(MultiSet_Intersection(msx,msy)) 
                    == MultiSet_Card(MultiSet_Union(msx,msy))
                ) && ( 
                    MultiSet_Card(MultiSet_Difference(msx,msy)) 
                    == MultiSet_Card(msx) - MultiSet_Card(MultiSet_Intersection(msx,msy))
                )
    }

    //axiom ms_subset_

    axiom ms_equal {
        forall msx: MultiSet, msy: MultiSet :: 
            { MultiSet_Equal(msx, msy) }
                MultiSet_Equal(msx, msy) <==> 
                forall o: Int :: { _(msx,o) } { _(msy,o) } _(msx,o) == _(msy,o)
    }

    axiom ms_equal_relation {
        forall msx: MultiSet, msy: MultiSet ::
            { MultiSet_Equal(msx, msy) }
                MultiSet_Equal(msx, msy) ==> msx == msy
    }

    //axiom ms_disjoint

    //axiom ms_from_set

    axiom ms_from_seq_good {
        forall s: Seq[Int] :: 
            { MultiSet_FromSeq(s) }
                ___IsGoodMultiSet___(MultiSet_FromSeq(s))
    }    

    axiom ms_from_seq_card {
        forall s: Seq[Int] :: 
            { MultiSet_Card(MultiSet_FromSeq(s)) }
                MultiSet_Card(MultiSet_FromSeq(s)) == |s|
    }

    axiom ms_from_seq_append {
        forall s: Seq[Int], v: Int :: 
            { MultiSet_FromSeq(s ++ Seq(v)) }
                MultiSet_FromSeq(s ++ Seq(v)) == MultiSet_UnionOne(MultiSet_FromSeq(s), v)
    } 

    /*
    axiom ms_from_seq_empty {
        MultiSet_FromSeq(Seq[Int]()) == MultiSet_Empty()
    }*/
    
    axiom ms_from_seq_union {
        forall sa: Seq[Int], sb: Seq[Int] ::
            { MultiSet_FromSeq(sa ++ sb) }
                  MultiSet_FromSeq(sa ++ sb) == MultiSet_Union(MultiSet_FromSeq(sa), MultiSet_FromSeq(sb))
    }

    axiom ms_from_seq_update {
        forall s: Seq[Int], i: Int, v: Int, x: Int ::
            { _(MultiSet_FromSeq(s[i := v]),x) }
                0 <= i && i < |s| ==>
                    _(MultiSet_FromSeq(s[i := v]), 
                    x) == 
                    _(MultiSet_Union( 
                        MultiSet_Difference( MultiSet_FromSeq(s), MultiSet_Singleton(s[i]) ), 
                        MultiSet_Singleton(v) ),
                    x)
    }

    axiom ms_from_seq_exists {
        forall s: Seq[Int], x: Int :: 
            { _(MultiSet_FromSeq(s),x) }
                ( exists i: Int :: 
                    //{ s[i] }
                        0 <= i && i < |s| && x == s[i] )
                        <==> 0 < _(MultiSet_FromSeq(s),x) 
    }

    /*axiom ms_from_seq_swap {
        forall s: Seq[Int], i: Int, j: Int, x: Int ::
            { _(MultiSet_FromSeq(s[i:=s[j]][j:=s[i]]),x) }
                _(MultiSet_FromSeq(s[i:=s[j]][j:=s[i]]),x) ==
                _(MultiSet_FromSeq(s),x)
    }*/
}


field val: Bool

domain Array {
    function loc(a: Array, i: Int): Ref
    function length(a: Array): Int

    axiom array_length {
      forall a: Array :: { length(a) } length(a) >= 0
    }

    /* Currently, injectivity is assumed automatically when inhaling permissions through quantifiers. 
    axiom array_injectivity {
      true  
      && ( forall a: Array, i: Int, j: Int :: { loc(a,i), loc(a,j) } 0 <= i && i < j && j < length(a) ==> loc(a,i) != loc(a,j) )
      && ( forall a: Array, i: Int, j: Int :: { loc(a,i), loc(a,j) } loc(a,i) == loc(a,j) <==> i == j )
    }*/
}

function a2s(a: Array): Seq[Int]
  requires forall i: Int :: i in [0..length(a)) ==> acc(loc(a,i).val)
  ensures |result| == length(a)
  ensures  forall i: Int :: { loc(a,i).val } { result[i] } i in [0..length(a)) ==> result[i] == (loc(a,i).val ? 1 : 0)


method two_way_sort(a: Array)
  // Works for empty arrays, too. 
  //requires length(a) > 0
  requires forall z: Int :: 0 <= z && z < length(a) ==> acc(loc(a,z).val)
  ensures  forall z: Int :: 0 <= z && z < length(a) ==> acc(loc(a,z).val)

  // The resulting array is sorted in ascending order. 
  ensures forall y: Int, z: Int :: { loc(a,y).val, loc(a,z).val } 0 <= y && y < z && z < length(a) ==> lte(loc(a,y).val, loc(a,z).val)

  // The number of false elements in the resulting state of the array is the same as in the initial state.   
  ensures MultiSet_Equal( MultiSet_FromSeq(a2s(a)), old(MultiSet_FromSeq(a2s(a))) )
{
  var i: Int := 0
  var j: Int := length(a) - 1  

  var xs: Seq[Int] 
  var ys: Seq[Int]
  var zs: Seq[Int]

  while ( i <= j )
    invariant 0 <= i && i <= j + 1 && j < length(a)
    invariant forall z: Int :: 0 <= z && z < length(a) ==> acc(loc(a,z).val)
    

    // The segment [0..i) contains only false elements
    // The segment [i..j] contains both false and true elements (invariant omitted)
    // The segment (j..length(a)) contains only 
    invariant forall z: Int :: { loc(a,z).val } 0 <= z && z < i ==> !loc(a,z).val
    invariant forall z: Int :: { loc(a,z).val } j < z && z < length(a) ==> loc(a,z).val

    invariant MultiSet_Equal( MultiSet_FromSeq(a2s(a)), old(MultiSet_FromSeq(a2s(a))) )
  {
    if ( !loc(a,i).val ) {
      i := i+1
    }
    elseif ( loc(a,j).val ) {
      j := j-1
    }
    else {
      xs := a2s(a)
      swap(a, i, j)
      ys := a2s(a)
      zs := xs [j := xs[i]] [i := xs[j]]
      assert forall z: Int :: z in [0..length(a)) ==> zs[z] == ys[z]
      assert zs == ys


      i := i+1
      j := j-1
    }
  }
}

method swap(a: Array, i: Int, j: Int)
  requires acc(loc(a,i).val) && acc(loc(a,j).val)
  ensures  acc(loc(a,i).val) && acc(loc(a,j).val)
  ensures loc(a,i).val == old(loc(a,j).val)
  ensures loc(a,j).val == old(loc(a,i).val)  
{
  var temp: Bool := loc(a,i).val
  loc(a,i).val := loc(a,j).val
  loc(a,j).val := temp
}

function lte(b1: Bool, b2: Bool): Bool {
  !b1 || b2
}
